---
title: 高级类型
---

# {{ $frontmatter.title }}

## 泛型

泛型类似于函数参数，先声明泛型坑位，使用时传递具体的类型

```typescript
type MaybeNull<T> = T | null
```

函数参数可以有默认值，泛型同样可以设置默认值

```typescript
type Factory<T = boolean> = T | number | string
const foo: Factory = false
```

泛型可以通过设置**泛型约束**对允许传递的类型进行限制

```typescript
type SuccessCode = 10000 | 10001 | 10002

type ResStatus<Code extends number> = Code extends SuccessCode
  ? 'success'
  : 'failed'
```

对传入的多个泛型参数，可以进行相关联的操作

```typescript
type Conditional<T, Condition, Truthy, Falsy> = T extends Condition
  ? Truthy
  : Falsy

type Result1 = Conditional<'', string, 'passed!', 'rejected!'>
```

**多泛型参数其实就像接受更多参数的函数，内部的运行逻辑（类型操作）可能会更加抽象** 

在函数中使用泛型，会进行**类型的自动提取** 

- 在函数接收到参数时，泛型会被自动的填充为参数的类型
- 并且参数的类型信息会被推断到尽可能精确的程度
  - 直接传入一个值，会**推导到字面量类型** 
  - 传入变量时仅会推导到变量标注的类型

```typescript
function handle<T>(input: T): T { return input }

const author = ''

let age = 18

handle(author) // function handle<"">(input: ""): ""
handle(age) // function handle<number>(input: number): number
```

## 类型系统

Typescript 是结构化类型系统，即不通过名称比较类型，而是比较这两个类型上实际拥有的属性与方法

```typescript
class Cat {
  eat() { }
}

class Dog {
  eat() { }
}

function feedCat(cat: Cat) { }

feedCat(new Dog())
```

Typescript 的类型系统也可以认为是**鸭子类型**，其核心理念是**如果你看到一只鸟走起来像鸭子，游泳像鸭子，叫得也像鸭子，那么这只鸟就是鸭子** 

严格来说，鸭子类型系统和结构化类型系统并不完全一致，结构化类型系统意味着**基于完全的类型结构来判断类型兼容性**，而鸭子类型则只基于**运行时访问的部分**来决定

由于 TypeScript 本身并不是在运行时进行类型检查，同时官方文档中同样认为这两个概念是一致的

所以在 TS 中我们可以直接认为鸭子类型与结构化类型是同一概念

## 类型层级

类型层级实际上指的是**类型的兼容关系**，也就是一个类型是否是另一个类型的子类型

所谓的上层与底层，其实即意味着包含类型信息的多少

### top type

`any` / `unknown` 是 TypeScript 中的两个Top Type类型，所有的类型都是这两个的子类型

```typescript
type Result_Any = CheckCompatibility<1, any> // true
type Result_Unknow = CheckCompatibility<Object, unknown> // true
```

`any` 和 `unknown` 类型的比较是互相成立

```typescript
type Result31 = any extends unknown ? 1 : 2  // 1
type Result32 = unknown extends any ? 1 : 2  // 1
```

当**条件类型中接受判断的类型**为 `any`，会直接**返回条件类型结果组成的联合类型** 

```typescript
type Result26 = any extends 'any' ? 1 : 2 // 1 | 2
type Result27 = any extends string ? 1 : 2 // 1 | 2
type Result28 = any extends {} ? 1 : 2 // 1 | 2
type Result29 = any extends never ? 1 : 2 // 1 | 2
```

因为 `any` 代表了任何可能的类型，`any extends` 同时包含了**让条件成立以及不成立的一部分** 



在赋值给其他类型时，any 来者不拒，而 unknown 则只允许赋值给 unknown 类型和 any 类型，这也是由于“系统设定”的原因，即 **any 可以表达为任何类型**。

### Bottom type

`never` 类型位于类型层级的对底层，**不携带任何的类型信息**，所以是任何类型的子类型

```typescript
type Never1 = never extends 'never' ? 1 : 2; // 1
type Never2 = never extends undefined ? 1 : 2 // 1
type Never3 = never extends void ? 1 : 2 // 1 
type Never4 = never extends null ? 1 : 2 // 1
```

当通过泛型传入的参数为 `never`，则会直接返回 `never` 

```typescript
type Tmp<T> = T extends string ? 1 : 2
type TmpRes = Tmp4<never> // never
```

### 层级关系

TypeScript 中大致的类型层级关系

- **字面量类型 < 对应的原始类型** 
- **字面量类型 < 包含此字面量类型的联合类型** 
- **原始类型 < 包含此原始类型的联合类型** 
- **同一基础类型的字面量联合类型 < 此基础类型** 
- **原始类型 < 原始类型对应的装箱类型 < Object 类型** 

```typescript
// 字面量类型 < 对应的原始类型
type Result_1 = 1 extends number ? 1 : 2 // 1

// 字面量类型 < 包含此字面量类型的联合类型
type Result_2 = 1 extends 1 | 2 | 3 ? 1 : 2 // 1

// 原始类型 < 包含此原始类型的联合类型
type Result_3 = string extends string | false | number ? 1 : 2 // 1

// 同一基础类型的字面量联合类型 < 此基础类型
type Result_4 = 1 | 2 | 3 extends number ? 1 : 2 // 1

// 原始类型 < 原始类型对应的装箱类型 < Object 类型
type Result_5 = string extends String ? 1 : 2 // 1
```

由于结构化类型，TS 中存在着一些不符合直觉的行为，对于 `{}` 类型的一些判断

```typescript
type Result_1 = {} extends object ? 1 : 2 // 1
type Result_2 = object extends {} ? 1 : 2 // 1

type Result_3 = object extends Object ? 1 : 2 // 1
type Result_4 = Object extends object ? 1 : 2 // 1

type Result_5 = Object extends {} ? 1 : 2 // 1
type Result_6 = {} extends Object ? 1 : 2 // 1
```

`{} extends ` 和 `extends {}` 是两种完全不同的比较方式

- `{} extends` 是从**类型信息的层面**出发
  - 即 `{}` 是 `object` 和 `Object` 的字面量类型
  - **字面量类型在基础类型之上提供了更详细的类型信息** 

- `extends {}` 是从**结构化类型系统的比较**出发的
  - `{}` 作为一个一无所有的空对象，几乎可以被视作是所有类型的基类

### 类型断言

实际上类型断言的工作原理也和类型层级有关

一个断言能否成立（类型差异是否能接受），实际上在判断这两个类型是否能够找到一个公共的父类型

比如 `{}` 和 `{ name: string }` 可以认为拥有公共的父类型 `{}` 

如果找不到具有意义的公共父类型，可以使用 **Top Type**，可以把它先断言到 **Top Type**，那么就拥有了公共父类型，再断言到具体的类型

```typescript
const str: string = ''

(str as (string | { handler: () => {} }) as { handler: () => {} }).handler()
```

## 条件类型

条件类型即使用 `extends` 对类型进行判断

- `extends` 判断类型的**兼容性**，而非判断类型的全等性

- 条件类型绝大部分场景下会和泛型一起使用

```typescript
type Result = {} extends Object ? 1 : 2 // 1
```

### infer

TypeScript 中支持通过 `infer` 关键字来**在条件类型中提取类型的某一部分信息** 

```typescript
type Func = (...args: any[]) => any

type FunctionReturnType<T extends Func> = T extends (
  ...args: any[]
) => infer R
  ? R
  : never
```

- `infer` 是 `inference` 的缩写（意为推断），`infer  ` 后的类型 `R` 表示**待推断的类型** 
- 对于条件类型中的 `infer X`，将其视为 `any` 即可

使用 `infer` 的**类型结构**并不局限于函数类型结构，还可以是数组

```typescript
type Swap<T extends any[]> = T extends [infer A, infer B] ? [B, A] : T

// 提取首尾两个
type ExtractStartAndEnd<T extends any[]> = T extends [infer Start, ...any[], infer End] ? [Start, End] : T
  
// 调换首尾两个
type SwapStartAndEnd<T extends any[]> = T extends [infer Start, ...infer Left, infer End] ? [End, ...Left, Start] : T

// 调换开头两个
type SwapFirstTwo<T extends any[]> = T extends [infer Start1, infer Start2, ...infer Left] ? [Start2, Start1, ...Left] : T
```

`infer` 可以和 rest 操作符一样同时提取一组不定长的类型

对于接口类型 `infer` 同样可以使用

```typescript
// 提取对象的属性类型
type PropType<T, K extends keyof T> = T extends { [Key in K]: infer R } ? R : never

// 反转键名与键值
type ReverseKeyValue<T extends Record<string, string>> = T extends Record<infer K, infer V> ? Record<V & string, K> : never
```

泛型参数 `V` 的来源是从键值类型推导出来的，TypeScript 中这样对键值类型进行 `infer` 推导，将导致类型信息丢失，而不满足索引签名类型只允许 `string | number | symbol` 的要求

使用 `V & string` 这一形式，就确保了最终符合条件的类型参数 V 一定会满足 `string | never` 这个类型，因此可以被视为合法的索引签名类型。

`infer` 结构还可以是 `Promise` 结构

```typescript
type PromiseValue<T> = T extends Promise<infer V> ? V : T
```

TypeScript 4.7 支持了 infer 约束功能来实现**对特定类型地提取** 

```typescript
type FirstArrayItemType<T extends any[]> = T extends [infer P extends string, ...any[]]
  ? P
  : never
```



### 分布式特性

**分布式条件类型（*Distributive Conditional Type*），也称条件类型的分布式特性**，条件类型在满足一定情况下会执行的逻辑

> ***Conditional types in which the checked type is a naked type  parameter are called distributive conditional types. Distributive  conditional types are automatically distributed over union types during  instantiation.*** 
>
> 对于属于裸类型参数的检查类型，条件类型会在实例化时期自动分发到联合类型上

也就是**联合类型**通过**泛型**参数传入进行**条件类型**的判断，并且条件类型中的泛型参数**裸露**

此时就会产生**条件类型分布式特性**：将联合类型拆开来，每个分支分别进行一次条件类型判断，再将最后的结果合并起来

```typescript
type Naked<T> = T extends boolean ? 'Y' : 'N'

type Resust = Naked<number | boolean> // "N" | "Y"
```

泛型参数是否完全裸露也就是指的直接使用泛型参数，当想禁用分布式特性可以包裹泛型参数

```typescript
export type NoDistribute<T> = T & {}

type Wrapped<T> = NoDistribute<T> extends boolean ? 'Y' : 'N'

type CompareUnion<T, U> = [T] extends [U] ? true : false
```

通过将参数与条件都包裹起来，转变成数组成员类型的比较，此时会严格遵守类型层级进行判断

- 可以禁用条件类型的分布式特性
- 可以解决 `any` 和 `never` 的问题，可以实际的去执行类型的判断

```typescript
type Tmp1<T> = T extends string ? 1 : 2
type Tmp1Res = Tmp2<any> // 1 | 2

type Tmp2<T> = T extends string ? 1 : 2
type Tmp2Res = Tmp4<never> // never

type IsNever<T> = [T] extends [never] ? true : false

type IsNeverRes1 = IsNever<never> // true
```

### IsAny

```typescript
type IsAny<T> = 0 extends 1 & T ? true : false
```

交叉类型**就像短板效应，最终的结果是最短的那根木板** 

```typescript
type Tmp1 = 1 & (0 | 1) // 1
type Tmp2 = 1 & number // 1
type Tmp3 = 1 & 1 // 1
```

大多时候 `1 & T ` 的结果为 `1` / `never`，所以 `0 extends 1 & T` 是不会成立的

但当 `any` 出现时 `1 & any` 的结果为 `any`，此时`0 extends 1 & T` 成立

### IsUnknow

利用 `unknown extends T` 仅当 `T` 为 `any` 或 `unknown` 时成立

```typescript
type IsUnknown<T> = unknown extends T
  ? IsAny<T> extends true
    ? false
    : true
  : false
```

## 工具类型

TypeScript 内置了一些工具类型，包括访问性修饰、结构、集合以及模式匹配工具类型

### 属性修饰

属性修饰工具类型主要使用**属性修饰**、**映射类型**与**索引类型**相关

```typescript
type Partial<T> = { [P in keyof T]?: T[P] }

type Required<T> = { [P in keyof T]-?: T[P] }

type Readonly<T> = { readonly [P in keyof T]: T[P] }
```

- `?` 可以标记属性为可选，`-?` 相当于在原本属性上如果有 `?` 这个标记则移除它
- 其实也可以使用 `+?` 来显式的表示添加可选标记

```typescript
type Partial<T> = { [P in keyof T]+?: T[P] }
```

可选标记不等于修改此属性类型为 `原类型 | undefined`

对于结构声明来说，一个属性是否必须提供仅取决于其是否携带可选标记

```typescript
interface Foo {
  optional: string | undefined;
  required: string;
}

// 类型 "{ required: string; }" 中缺少属性 "optional"，但类型 "Foo" 中需要该属性。
const foo1: Foo = {
  required: '1',
};

const foo2: Foo = {
  required: '1',
  optional: undefined
}
```

类似 `+?`，`readonly` 也可以使用 `+readonly` 

```typescript
type Readonly<T> = { +readonly [P in keyof T]: T[P] }
```

很容易想到可以实现一个工具类型 `Mutable`，将 `readonly` 修饰移除

```typescript
type Mutable<T> = { -readonly [P in keyof T]: T[P] }
```

### 结构工具类型

结构工具类型主要使用**条件类型**以及**映射类型**、**索引类型** 

结构工具类型又可以分为两类，**结构声明**和**结构处理 ** 

- 结构声明工具类型即快速声明一个结构，比如内置的 `Record` 
- 结构处理工具类型，内置的主要是 `Pick`、`Omit` 

```typescript
type Record<K extends keyof any, T> = { [P in K]: T }

type Pick<T, K extends keyof T> = { [P in K]: T[P] }

type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

### 集合工具类型

集合工具类型主要使用条件类型、条件类型分布式特性

对于两个集合来说，通常存在**交集、并集、差集、补集**这么几种情况

- **并集**：两个集合的合并
- **交集**：两个集合的相交部分
- **差集**：A 相对于 B 的差集即为**A 中独有而 B 中不存在的元素**的组成的集合
  - 或者说 **A 中剔除了 B 中也存在的元素以后，还剩下的部分** 
- **补集**：补集是差集的特殊情况
  - **集合 B 为集合 A 的子集**情况下 **A 相对于 B 的差集** + **B** = **完整的集合 A** 

TS 内置的工具类型中提供了交集与差集的实现

```typescript
type Extract<T, U> = T extends U ? T : never

type Exclude<T, U> = T extends U ? never : T
```

对于交集 Extract ，其运行逻辑是这样的

```typescript
type AExtractB = Extract<1 | 2 | 3, 1 | 2 | 4> // 1 | 2

type _AExtractB =
  | (1 extends 1 | 2 | 4 ? 1 : never) // 1
  | (2 extends 1 | 2 | 4 ? 2 : never) // 2
  | (3 extends 1 | 2 | 4 ? 3 : never) // never
```

除了差集和交集，我们也可以很容易实现并集与补集

```typescript
// 并集
export type Concurrence<A, B> = A | B

// 交集
export type Intersection<A, B> = A extends B ? A : never

// 差集
export type Difference<A, B> = A extends B ? never : A

// 补集
export type Complement<A, B extends A> = Difference<A, B>
```

内置工具类型中还有一个场景比较明确的集合工具类型

```typescript
type NonNullable<T> = T extends null | undefined ? never : T
```

### 模式匹配

模式匹配工具类型主要使用**条件类型**与 **infer 关键字** 

infer 其实代表了一种 **模式匹配（pattern matching）** 的思路

正则表达式、Glob 中等都体现了这一概念

函数类型签名的模式匹配：

```typescript
type FunctionType = (...args: any) => any;

type Parameters<T extends FunctionType> = T extends (...args: infer P) => any ? P : never;

type ReturnType<T extends FunctionType> = T extends (...args: any) => infer R ? R : any;
```

对 Class 进行模式匹配：

```typescript
type ClassType = abstract new (...args: any) => any;

type ConstructorParameters<T extends ClassType> = T extends abstract new (
  ...args: infer P
) => any
  ? P
  : never;

type InstanceType<T extends ClassType> = T extends abstract new (
  ...args: any
) => infer R
  ? R
  : any;
```

Class 的通用类型签名可能看起来比较奇怪，但实际上它就是声明了可实例化（new）与可抽象（abstract），也可以使用接口来进行声明

```typescript
export interface ClassType<TInstanceType = any> {
    new (...args: any[]): TInstanceType;
}
```

## 上下文类型

上下文类型的核心理念：**基于位置的类型推导** 

```typescript
type CustomHandler = (name: string, age: number) => boolean

// 推导出了参数类型
const handler: CustomHandler = (arg1, arg2) => true
```

相对于基于开发者的输入进行类型推导，上下文类型更像是**反方向的类型推导**，也就是**基于已定义的类型来规范开发者的使用** 

在上下文类型中，我们实现的表达式可以只使用更少的参数，而不能使用更多，这还是因为上下文类型基于位置的匹配，一旦参数个数超过定义的数量，那就没法进行匹配了

上下文类型也可以进行”嵌套“情况下的类型推导

```typescript
declare let func: (raw: number) => (input: string) => any;

// raw → number
func = (raw) => {
  // input → string
  return (input) => {};
}
```

某些情况下上下文类型的推导能力也会失效，比如使用一个由函数类型组成的联合类型

```typescript
type Fn =  ((input: string) => void) | ((input: number) => void)

let fn: Fn = (input) => {}  // 参数“input”隐式具有“any”类型
```

预期的结果是 input 被推导为 `Foo | Bar` 类型，但是 TypeScript 中的上下文类型目前暂时不支持这一判断方式

而如果联合类型中将这两个类型再嵌套一层，此时上下文类型反而正常

```typescript
type Fn =
  | { (raw: number): (input: Foo) => void }
  | { (raw: number): (input: Bar) => void }

let f3: Fn = (raw) => {
  return (input) => { }
}
```

## 协变与逆变

对于函数类型比较，实际上要比较的是参数类型与返回值类型

如果 `Triangle` 是 `Shape` 的子类型

- **协变**：如果一个类型保留其底层类型的子类型关系，就称该类型具有协变性
  - 数组具有协变性，`Triangle[]` 是 `Shape[]` 的子类型
  - 函数的返回类型具有协变性

- **逆变**：如果一个类型颠倒了其底层类型的子类型关系，则称该类型具有逆变性
  - 大部分编程语言中，函数的实参是逆变
  - 一个接受 `Triangle` 作为实参的函数可以被接受 `Shape` 作为实参的函数

- **双变**：类型的底层类型的子类型关系决定了它们互为子类型
  - TS 默认函数的参数具有双变性
  - `(x: Shape) => void` 和 `(x: Triangle) => void` 互为子类型

开启 [strictFunctionTypes](https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Ftsconfig%23strictFunctionTypes) 配置对函数**参数类型启用逆变检查** 

在 TypeScript ESLint 中，有这么一条规则：[method-signature-style](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fmethod-signature-style.md)，它的意图是约束在接口中声明方法时，需要使用 **property** 而非 **method** 形式

```typescript
// method 声明
interface T1 {
  func(arg: string): number;
}

// property 声明
interface T2 {
  func: (arg: string) => number;
}
```

开启严格函数类型检查的时候，只有 `property` 声明享受到**基于逆变的参数类型检查** 

对于 method 声明（以及构造函数声明），其无法享受到这一更严格的检查的原因则是对于如 Array 这样的内置定义，我们希望它的函数方法就是以协变的方式进行检查，举个栗子，`Dog[] ≼ Animal[]` 是否成立？

- 我们并不能简单的比较 Dog 与 Animal，而是要将它们视为两个完整的类型比较，即 `Dog[]` 的每一个成员（属性、方法）是否都能对应的赋值给 `Animal[]` ？
- `Dog[].push ≼ Animal[].push` 是否成立？
- 由 push 方法的类型签名进一步推导，`Dog -> void ≼ Animal -> void` 是否成立？
- `Dog -> void ≼ Animal -> void`在逆变的情况下意味着 `Animal ≼ Dog`，而这很明显是不对的！
- 简单来说， `Dog -> void ≼ Animal -> void` 是否成立本身就为 `Dog[] ≼ Animal[]` 提供了一个前提答案。

因此，如果 TypeScript 在此时仍然强制使用参数逆变的规则进行检查，那么 `Dog[] ≼ Animal[]` 就无法成立，也就意味着无法将 Dog 赋值给 Animal，这不就前后矛盾了吗？所以在大部分情况下，我们确实希望方法参数类型的检查可以是**双变**的，这也是为什么它们的声明中类型结构使用 method 方式来声明：

```typescript
interface Array<T> {
    push(...items: T[]): number;
}
```

## 模板字符串类型

通过与 JavaScript 中模板字符串相同的语法，对字符串的类型进行更强的约束

```typescript
type World = 'World'

type Greeting = `Hello ${World}` // "Hello World"
```

目前有效的类型只有 `string | number | boolean | null | undefined | bigint` 可以插入 `${}` 中，包括其子类型（字面量）

### 自动分发

可以利用其**自动分发的特性**来实现简便而又严谨的声明

```typescript
type Brand = 'iphone' | 'xiaomi' | 'honor'
type Memory = '16G' | '64G'
type ItemType = 'official' | 'second-hand'

type SKU = `${Brand}-${Memory}-${ItemType}`
// "iphone-16G-official" | "iphone-16G-second-hand" | "iphone-64G-official" | "iphone-64G-second-hand" | "xiaomi-16G-official" | "xiaomi-16G-second-hand" | "xiaomi-64G-official" | ... 4 more ... 
```

自动分发特性结合索引类型与映射类型，可以基于对象类型实现精确到字面量的类型推导

### 专用工具类型

字符串专用的工具类型，包括 **Uppercase**、**Lowercase**、**Capitalize** 与 **Uncapitalize** 

这是 TypeScript 中首次引入了**能直接改变类型本身含义**的工具类型

其源码定义为 `intrinsic`，表明这一工具类型由 TypeScript 内部进行实现

```typescript
type Uppercase<S extends string> = intrinsic
type Lowercase<S extends string> = intrinsic
type Capitalize<S extends string> = intrinsic
type Uncapitalize<S extends string> = intrinsic
```

### 模式匹配

模式匹配工具类型的核心理念就是对符合约束的某个类型结构，提取其某一个位置的类型

可以将一个字符串类型视为一个结构，在其中也可以应用模式匹配相关的能力

模板插槽不仅可以声明一个占位的坑，也可以声明一个要提取的部分

```typescript
type Reverse<S extends string> = S extends `${infer first} ${infer last}` ? `${last} ${first}` : S
```

除了使用 `infer`，由于模板字符串的灵活性，可以直接通过泛型来进行模式匹配操作

```typescript
declare function name<S extends string>(arg: `name: ${S}`): S

who('name: a')  // 'a'
```

