---
title: 工程层面
---

# {{ $frontmatter.title }}

## 类型检查指令

TypeScript 中提供了数个行内注释（可称为类型指令），进行单行代码或单文件级别的配置能力。

这些指令均以 `// @ts-` 开头 

- `ts-ignore` 
  - 直接禁用掉对下一行代码的类型检查
  - 基本上所有的类型报错都可以通过这个指令来解决
  - 本质是上 ignore 而不是 disable，如果下一行代码并没有问题，使用 ignore 其实是一个错误
- `ts-expect-error` 
  - 一个更严格版本的 ignore
  - 只有在**下一行代码真的存在错误时**才能被使用，否则它会给出一个错误
- `ts-nocheck` 
  - 一个作用于整个文件的 ignore 指令
  - 使用了 `ts-nocheck` 指令的 TS 文件将不再接受类型检查
- `ts-check` 
  - TypeScript 对 JS 文件可以通过**类型推导**与 JSDoc 的方式进行不完全的类型检查
  - 使用 `ts-check` 指令可以让 TypeScript 对该 JS 文件进行类型检查
  - 通过 `tsconfig.json` 的 `checkJs` 可以开启对 JS 文件的类型检查

在开启了对 JS 文件的检查之后，另外三个指令也可以在具有类型检查的 JS 文件中使用

## 类型声明

类型声明本质就是 `declare` 语法，我们可以直接访问这些声明，但不能为这些声明变量赋值

```typescript
// main.ts
declare const hello: string

const world = 'world'

declare interface Foo {
  prop: string
}
```

对于 `declare const` 可以使用字符串、数字、枚举字面量进行初始化赋值（类型推导）

```typescript
enum ModuleType { CSS, SCRIPT}

declare const type = ModuleType.SCRIPT

declare const num = 10
```

当一个文件中不存在**顶层**的 `import` 或 `export`，文件内声明的都是全局变量或全局类型

这些全局变量/类型在其他任何地方都可以直接使用，和使用这些类型的文件是否是模块环境无关

```typescript
// sub.ts
const foo: Foo = {
  prop: 'a'
}
console.log(hello, world)

export default {}
```

和 TS 的 `module` 配置也无关，没有**顶层** `import` / `export` 的文件中所有的声明一定是全局的

### 声明文件

类型声明文件，即 `.d.ts` 结尾的文件，它会自动地被 TS 加载到环境中，实现对应部分代码的类型补全

类型声明即**通过额外的类型声明文件，在核心代码文件以外去提供对类型的进一步补全** 

类型声明的核心作用：**将类型独立于 `js` 文件进行存储**，在使用时能够获得这些额外的类型信息

- 声明文件中并不包含实际的代码逻辑，仅仅只是类型标注，使用的语法仍然是 `declare` 关键字
- 声明文件只在开发阶段有用，用于声明一些变量或者类型
  - 以免 TS 在做检查的时候抛出变量或类型不存在的错误，从而导致编译失败
  - 同时可以获得对应的代码补全、接口提示等
- 默认情况下，TS 会解析项目内所有 `.d.ts` 文件

### 声明语法

声明语法即 `declare` 的语法，`declare` 可以在 TS 文件中使用，也可以在 `.d.ts` 文件中使用

- `declare var/let/const` 声明变量和常量
  - `var`  和 `let` 用于声明普通变量，`const` 用于声明只读的常量
  - 通常全局变量都应该是只读的，所以应该尽量使用 `const` 
- `declare function` 声明函数、`declare class` 声明类、`declare enum` 声明枚举
- `declare namespace` 声明命名空间
  - 命名空间内部的属性声明无需使用 `export` 和 `declare` 
  - 可以嵌套命名空间且无需 `export` 和 `declare` 
- `declare interface` 声明接口、`declare type` 声明类型别名
  - 对于 `interface` 和 `type` 的类型声明语法，`declare` 关键字可以省略
  - [关于interface 和 declare interface 的区别](https://stackoverflow.com/questions/38683155/difference-between-interface-and-declare-interface) 

```typescript
declare const hello: string
declare function fn(x: string): string
declare class People {
  name: string
  constructor (name: string)
  sayHi (): string
}
declare enum ModuleType { CSS, SCRIPT }

declare namespace B {
  const prop: number
  namespace C { }
}
```

#### 声明合并

如果声明了两个以上的同名函数、同名接口或同名类 ，那么它们会合并成一个类型

声明合并可以在以下情况下发生：

- `interface + interface` 
- `namespace + namespace` 
- `class + interface` 
- `class + namespace` 
- `class + interface + namespace` 
- `function + namespace` 
- `enum + namespace` 

如果声明的同名变量不是函数、接口或类，只以第一次声明的类型为准

**利用声明合并可以扩展全局对象的属性** 

```typescript
interface Window {
  sum(a: number, b: number): number
}

console.log(window.sum(3, 2))
```

#### 声明扩展

- `declare global` 在模块中声明全局变量或全局类型
- `declare module` 声明模块或扩展模块

**模块声明文件** 

TS 一个文件中只要没有出现 `import` 或 `export`，文件内声明的都是全局变量或全局类型

声明文件默认为全局声明文件，出现 `import` 或 `export` 的声明文件就是**模块声明文件** 

- 模块声明文件中所有声明都属于局部声明
- 其中声明的类型只能在内部使用，或者通过 `export` 导出

##### 全局扩展

如果必须要在模块声明文件/模块文件中，声明一些全局变量或全局类型，可以通过 `declare global` 块来完成

```typescript
declare global {
  const bar: string
  function globalFn<T>(x: T): T

  interface Window {
    foo: string
  }

  interface IPeople {
    name: string
    age?: number
  }
}
export { }
```

`declare global` 块中无需再使用 `declare` 关键字

我们可以在全局使用 `JSX.Element` 作为类型标注的原因

```typescript
// @types/react/index.d.ts
declare global {
  namespace JSX {
    interface Element extends React.ReactElement<any, any> { }
  }
}
```

##### 模块扩展

`declare module` 可以为一个没有类型声明的模块声明

```tsx
type CSSModuleClasses = { readonly [key: string]: string }

declare module '*.module.css' {
  const classes: CSSModuleClasses
  export default classes
}

import styles from './index.modules.css'

const App = () => {
  return (
    <div className={styles['app']}></div>
  )
}
```

`declare module` 也可以用来扩展一个模块的类型声明

```typescript
declare module 'fs' {
  export function bump(): void
}

import { bump } from 'fs'
```

##### 三斜线指令

三斜线指令用于**声明当前的文件依赖的其他类型声明**，也就是导入所需的类型

当我们在编写一个全局声明文件但又依赖其他声明文件时，文件内不能出现 `import` 去导入其他声明文件的声明，此时就需要通过三斜线指令来引用其他的声明文件

三斜线指令本质上就是一个自闭合的 XML 标签，必须放在文件的最顶端，且前面只允许出现行注释

```typescript
/// <reference path="./other.d.ts" />
/// <reference types="node" /> // @types/node
/// <reference lib="dom" />  // lib.dom.d.ts
```

- `path` 使用相对路径引用文件
- `types` 的值为`@types/` 的包名
- `lib` 的值为TypeScript 内置的类型声明

#### 导入导出

在 TypeScript 中，导入导出一个类型和导入导出一个实际值是完全一样的

```typescript
// foo.ts
export const Foo = () => {}

export type FooType = any

// index.ts
import { Foo, FooType } from './foo'
```

通过 `import type` 语法，可以更好地区分值导入和类型导入

```typescript
import { Foo } from './foo'
import type { FooType } from './foo'
```

类型和值分开导入会造成导入语句数量激增，4.6 版本以后支持了变量级别的 type 声明

```typescript
import { Foo, type FooType } from './foo'
```

- `export =` 用于在 TS 中使用其他模块的通用语法（CommonJS、AMD、CMD）
  - 导出 `export = xxx`，导入必须使用 `import xxx = require("xxx")` 
  - [TS 对 CommonJS 和 AMD 模块语法的通用建模](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) 
- `export as namespace` 导出 UMD 库全局变量声明，例如 react 
  - 启用了 `allowUmdGlobalAccess` 配置时，允许将这个模块作为全局变量使用
  - 适用于通过 CDN 资源导入模块时的变量类型声明

### DefinitelyTyped

`@types/` 开头的一类 npm 包均属于 [DefinitelyTyped](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped) 

它是 TypeScript 维护的，专用于为社区存在的**无类型定义的 JavaScript 库**添加类型支持

所有 `@types/` 下的包默认都会自动被 TypeScript 加载

TS 查找一个 npm 包的**声明文件**的步骤：

1. 检测 `package.json` 中是否存在 `types` / `typings` 字段，否则继续查找
2. 检查包的根目录是否有存在 `index.d.ts` 声明文件，否则继续查找
3. 根据 `package.json` 中的 `main` 字段，检测入口文件同级目录下是否有同名的 `.d.ts` 文件
4. 都没有则认为此 npm 包完全没有声明文件（没有类型声明）

## 命名空间

TypeScript 支持使用 `namespace` 声明命名空间

- 命名空间内部就像是一个独立的代码文件，其中的变量需要导出以后才能使用
- 命名空间的使用方式类似于枚举
- 命名空间的内部还可以再嵌套命名空间

```typescript
namespace Utility {
  export function log() {
    console.log('Utility/log')
  }
  export function error() {
    console.log('Utility/error')
  }
}
Utility.log()
```

命名空间的编译产物与上古时期 JavaScript 使用的模块化方案一样

```typescript
var Utility;
(function (Utility) {
  function log() {
    console.log('Utility/log');
  }
  Utility.log = log;
  function error() {
    console.log('Utility/error');
  }
  Utility.error = error;
})(Utility || (Utility = {}));
```

TypeScript 引入命名空间（[1.5版本](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html#namespace-keyword)）用于实现简单的模块化功能

命名空间的一些特点：

- 类似于类型声明中的同名接口合并，重复声明的命名空间也可以进行合并
- 除了在 `.ts` 文件中使用以外，通过 `declare namespace` 也可以在声明文件中使用
- `declare namespace` 内部的类型声明我们不再需要使用 `declare` 关键字





