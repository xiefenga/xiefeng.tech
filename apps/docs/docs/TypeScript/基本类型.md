---
title: 基本类型
---

# {{ $frontmatter.title }}

## 原始类型

JavaScript 中的原始类型在 TypeScript 中都有对应的类型注解存在

包括 `number` / `string` / `boolean` / `null` / `undefined` / `symbol` 和 `bigint` 

### null 和 undefined 

`null` 与 `undefined` 在 TS 中都是**有具体意义的类型**，且默认会**被视作其他类型的子类型** 

```typescript
const tmp1: null = null
const tmp2: undefined = undefined

const tmp3: string = null
const tmp4: string = undefined
```

开启 `strictNullChecks` 可以获得更严格的空类型检查，只能赋值给 `null` 或 `undefined` 类型

```typescript
// strictNullChecks: true
const str: string = null // Type 'null' is not assignable to type 'string'
```

### void

JavaScript 中的 `void` 操作符会执行后面跟着的表达式并返回一个 `undefined` 

并且 `void` 操作符强制**将后面的函数声明转化为了表达式**，可以使用它来执行一个立即执行函数

```javascript
void function iife() {
  console.log("Invoked!");
}()
```

TS 中也有 `void` 类型，用于描述没有一个返回值的函数的返回值类型

- 没有 `return` 语句
- 没有显式 `return` 一个值

```typescript
function fn1() {}  // function fn1(): void
function fn2() { return } // function fn2(): void
function fn3() { return undefined } // function fn3(): undefined
```

显示 `return undefined` 的函数返回值类型会被推导为 `undefined` 

但依旧可以使用 `void` 进行标注，因为在类型层面都表示“没有返回一个有意义的值”

```typescript
function fn3(): void { return undefined }
```

`void` 表示一个**空类型**，而 `null` 与 `undefined` 都是一个**具有意义的实际类型** 

`undefined` 可以赋值给 `void` 类型的变量，就像一个没有返回值的函数默认返回一个 `undefined` 

```typescript
const v: void = undefined
```

而 `null` 默认无法赋值给 `void` 类型的变量，但在关闭 `strictNullChecks` 的情况下也可以

```typescript
const v: void = null // Type 'null' is not assignable to type 'void'
```

TypeScript 中 `void`、`undefined`、`null` 都是**切实存在、有实际意义的类型**，和其他的类型并没有什么本质区别

### unique symbol

`Symbol` 在 JavaScript 中代表着一个唯一的值类型

TS 中 `symbol` 类型并不具有唯一特性，每一个 `symbol` 类型的变量的都是同一个类型

为了实现“独一无二”的特性，TypeScript 中支持了 `unique symbol` 类型声明

它是 `symbol` 类型的子类型，而且每一个 `unique symbol` 类型都是独一无二的

```typescript
declare const foo: unique symbol

const bar: unique symbol = foo
// Type 'typeof foo' is not assignable to type 'typeof bar'.
```

如果要引用已创建的 `unique symbol` 类型，则需要使用类型查询操作符 `typeof` 

```typescript
declare const foo: unique symbol

const bar: typeof uniqueSymbolFoo = foo
```

## 数组

在 TypeScript 中有两种方式来声明一个数组类型

```typescript
const arr1: string[] = []

const arr2: Array<string> = []
```

如果约束一个对象为 `[]` 类型，则会被推导为 `never[]` 

## 元组

元组为一个固定长度的数组，并且数组中每一项的类型确定

使用元组能帮助我们进一步提升**数组结构的严谨性**，包括基于位置的类型标注、避免出现越界访问等

```typescript
const tuple: [string, number, boolean] = ['hello', 1, true]

tuple[10] // Tuple type '[string, number, boolean]' of length '3' has no element at index '10'.

const [str, num, bool, other] = tuple // Tuple type '[string, number, boolean]' of length '3' has no element at index '3'.
```

### 可选成员

元组也支持在某一个位置上为可选成员，此时元祖的长度是一个联合类型

```typescript
const tuple: [string, number?, boolean?] = ['hello']

// 也可以使用 ['hello', , ,] 

type TupleLength = typeof tuple.length // 1 | 2 | 3
```

- 开启 `strictNullCheckes`，标记为可选的成员会被视为 `string | undefined` 类型
- 关闭 `strictNullCheckes`，标记为可选的成员类型则为 `string` 类型
- `strictNullCheckes` 配置不影响长度的类型，依旧是 `1 | 2 | 3` 

### 具名元组

TS 4.0 开始支持具名元组（[Labeled Tuple Elements](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMicrosoft%2FTypeScript%2Fissues%2F28259)）

可以为元组中的元素打上类似属性的标记，提高元组的可读性

```typescript
type User = [name: string, age: number, male: boolean]

const user: User = ['0x1461A0', 18, true]
```

具名元组可选元素的修饰符使用以下形式

```typescript
type User = [name: string, age: number, male?: boolean]
```

## 对象类型

一般对象的类型标注可以使用 `type`、`interface`，两者的使用一个推荐的方式：

- `interface` 用来描述**对象、类的结构** 

- 类型别名用来**将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型** 

TS 中存在 `object`、`Object`、`{}` 三个类型可以约束对象，但是这三者会让人感到困惑

`object`、`Object`、`{}` 类型的区别

`Object` 类型包含了所有的类型，可以认为是一个装箱类型，其拆箱类型为各种类型

```typescript
// strictNullChecks: false
const o1: Object = 'hello'
const o2: Object = {}
const o3: Object = null
const o4: Object = undefined
```

类似的还有 `Boolean`、`Number`、`String` 这些**装箱类型**，不仅包括该类型的对象，还包括**拆箱类型** 

```typescript
const tmp1: String = 'hello'
const tmp2: String = new String('hello')
```

**在任何情况下，都不应该使用这些装箱类型 ** 

`object` 类型为了解决对 Object 类型的错误使用，它代表**所有非原始类型的类型** 

```typescript
const o1: object = { name: 'hello' }
const o2: object = () => {}
const o3: object = []
```

`{}` 可以认为是一个对象字面量类型，即一个**内部无属性定义的空对象**，但是和 `Object` 类型一样包含所有的类型

```typescript
// strictNullChecks: false
const o1: {} = undefined 
const o2: {} = null
const o1: {} = 'hello'
```

## 字面量类型

**Literal Types**，看起来就像一个值，而本质上是一个类型

- 代表着比原始类型更精确的类型，同时也是对应原始类型的子类型，

- 主要包括**字符串字面量类型**、**数字字面量类型**、**布尔字面量类型**和**对象字面量类型** 
- 原始类型的值可以包括任意的同类型值，而字面量类型要求的是**值级别的字面量一致** 

单独使用字面量类型比较少见，通常和联合类型一起使用，表达一组字面量类型

```typescript
interface Result {
  code: 10000 | 10001 | 50000
  status: 'success' | 'failed'
  data: unknown
}
```

- 无论是原始类型还是对象类型的字面量类型，它们的本质都是**类型**而不是值  
- 它们在编译时同样会被擦除，被存储在内存中的**类型空间**而非值空间

除了手动声明字面量类型以外，TypeScript 会在某些情况下将变量类型推导为字面量类型

- 使用 `const` 声明的变量，其类型会从值推导出最精确的字面量类型
- 对象字面量类型中属性会使用相应的原始类型，而不会使用字面量类型

![](https://oss.xiefeng.tech/images/20221220155009.png)

## 联合类型

联合类型代表了**一组类型的可用集合**，只要最终赋值的类型属于联合类型的成员之一就可以

- 联合类型对其成员并没有任何限制，可以将各种类型混合到一起，包括联合类型
- 同时存在字面量类型和原始类型，字面量类型会被合到原始类型中
- 嵌套的联合类型最终都会被展平到第一级中

```typescript
type Mixed = string | number | 599 | {} | (() => {}) | (1 | 2) | 'a'

type A = 'a' | 'A'

type B = 'b' | 'B'

type C = A | B | 'c' | 'C'  // 'a' | 'A' | 'b' | 'B' | 'c' | 'C'
```

联合类型的常用场景之一是通过多个对象类型的联合，来实现手动的互斥属性

```typescript
interface Vip {
  vip: true
  expires: string
}

interface NoVip {
  vip: false
  promotion: string
}

type User = Vip | NoVip

declare var user: User

if (user.vip) {
  console.log(user.expires)
}
```

## 枚举

TS 中使用 `enum` 关键字声明枚举类型

```typescript
enum PageUrl {
  Home_Page_Url = "url1",
  Setting_Page_Url = "url2",
  Share_Page_Url = "url3",
}
```

### 枚举特点

1. 如果没有声明枚举值，默认使用数字枚举，并且从 0 开始，以 1 递增
2. 如果为某一个成员指定了枚举值
   - 那么之前未赋值成员仍然会使用从 0 递增的方式
   - 之后的成员则会开始从枚举值递增（枚举值为数字，否则需手动指定）
3. 数字型枚举可以使用**延迟求值**的枚举值
   - 没有手动声明枚举值的枚举成员需要放在常量枚举值声明的成员之后，或者放在第一位
4. 可以同时使用字符串枚举值和数字枚举值

```typescript
enum Enum_Demo_1 {
  Foo, // 0 
  Bar, // 1
  Baz, // 2
}

enum Enum_Demo_2 {
  Foo, // 0 
  Bar = 599,
  Baz, // 600
}

const returnNum = () => 100 + 499

enum Enum_Demo_3 {
  Foo = returnNum(),
  Bar = 599,
  Baz, // 600
}

enum Enum_Demo_4 {
  Baz, // 0
  Foo = returnNum(),
  Bar = 599,
}

enum Mixed {
  Num, // 0
  Str = 'hello'
}
```

### 双向映射

枚举和对象的重要差异在于，**对象是单向映射的**，我们只能从键映射到键值。

TS 中的**枚举是双向映射的**，既可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员

```typescript
enum Items {
  Foo,
  Bar,
  Baz
}

const fooValue = Items.Foo; // 0
const fooKey = Items[0]; // "Foo"
```

枚举编译后的代码

```typescript
"use strict";
var Items;
(function (Items) {
    Items[Items["Foo"] = 0] = "Foo";
    Items[Items["Bar"] = 1] = "Bar";
    Items[Items["Baz"] = 2] = "Baz";
})(Items || (Items = {}));
```

仅有值为数字的枚举成员才能够进行这样的双向枚举，**字符串枚举成员仍然只会进行单次映射** 

```typescript
enum Items {
  Foo,
  Bar = "BarValue",
  Baz = "BazValue"
}

// 编译结果，只会进行 键-值 的单向映射
"use strict";
var Items;
(function (Items) {
    Items[Items["Foo"] = 0] = "Foo";
    Items["Bar"] = "BarValue";
    Items["Baz"] = "BazValue";
})(Items || (Items = {}));
```

除了数字枚举与字符串枚举这种分类以外，其实还存在着普通枚举与常量枚举这种分类方式

### 常量枚举

常量枚举和枚举相似，其声明多了一个 `const` 

```typescript
const enum Items {
  Foo,
  Bar,
  Baz
}

const fooValue = Items.Foo; // 0
```

它和普通枚举的差异主要在访问性与编译产物。

1. 对于常量枚举，你**只能通过枚举成员访问枚举值**（而不能通过值访问成员）
2. 编译产物中并不会存在一个额外的辅助对象，对枚举成员的访问会被**直接内联替换为枚举的值** 

```typescript
const fooValue = 0 /* Foo */; // 0
```

常量枚举的表现、编译产物还受到 `isolatedModules` 以及 `preserveConstEnums` 等配置影响

## 函数类型

函数的类型就是描述了**函数入参类型与函数返回值类型** 

JavaScript 中存在**函数声明（Function Declaration）**和**函数表达式（Function Expression）** 

所以函数的类型标注也具有两种形式

```typescript
function foo(name: string): number {
  return name.length
}

type Fn = (name: string) => number

const foo: Fn = (name) => {
  return name.length
}
```

如果只是为了描述函数的类型结构，我们甚至可以使用 `interface` 来进行函数声明

```typescript
interface FuncFooStruct {
  (name: string): number
}
```

此时 `interface` 被称为 **Callable Interface**，看起来可能很奇怪，但可以这么认为，`interface` 就是用来描述一个类型结构的，而函数类型本质上也是一个结构固定的类型

### 函数重载

TS 提供了**函数重载签名（Overload Signature）**，实现与入参关联的返回值类型

```typescript
function func(foo: number, bar: true): string
function func(foo: number, bar?: false): number
function func(foo: number, bar?: boolean): string | number {
  // ...
}
```

声明 TS 函数重载的一般步骤：

1. 声明函数的多个重载签名
2. 声明函数的实现签名，包含重载签名的所有可能情况

基于重载签名，可以实现将入参类型和返回值类型的可能情况进行关联，获得了更精确的类型标注能力

拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的

TypeScript 中的重载是伪重载，**它只有一个具体实现，其重载体现在方法调用的签名上而非具体实现上** 

而在如 C++ 等语言中，重载体现在多个**名称一致但入参不同的函数实现上**，这才是更广义上的函数重载

### 异步函数

**异步函数等类型签名 ** 

```typescript
async function asyncFunc(): Promise<void> {}

function* genFunc(): Iterable<void> {}

async function* asyncGenFunc(): AsyncIterable<void> {}
```

**Newable Interface** 

我们可以使用 **Newable Interface** 来描述一个类的结构，类似于描述函数结构的 **Callable Interface**

```typescript
class Foo { }

interface FooStruct {
  new(): Foo
}

declare const NewableFoo: FooStruct;

const foo = new NewableFoo();
```

## 特殊类型

### any

TypeScript 中提供了一个内置类型 `any`，用于接受任意类型的值

除了显式的标记，在很多时候变量/参数会被隐式地推导为 `any` 

- 使用 `let` 声明并没有初始化的变量
- 缺少类型标注的函数参数

```typescript
let foo // any

function func(foo /* any */, bar /* any */){}
```

启用 `noImplicitAny` 配置时，隐式的 `any` 推导会报错

`any` 主要意义为了表示一个**无拘无束的“任意类型”，能兼容所有类型，也能被所有类型兼容**  

本质是类型系统中的顶级类型，即 Top Type

实际由于关闭了类型推导与检查，`any` 类型的变量几乎无所不能

- 可以在声明后再次接受任意类型的值，同时可以被赋值给任意其它类型的变量
- 可以在该类型变量上任意地进行操作，包括赋值、访问、方法调用等等



### unknown

和 `any` 类型有些类似，如果想表达一个未知类型，使用 `unknown` 类型更加合理

`unknown` 类型的变量可以再次赋值为任意其它类型，但只能赋值给 `any` / `unknown` 类型的变量

```typescript
let unknownVar: unknown

unknownVar = false
unknownVar = 'str'
unknownVar = { }
unknownVar = () => { }

const val1: string = unknownVar // Error
const val2: number = unknownVar // Error
const val3: () => {} = unknownVar // Error
const val4: {} = unknownVar // Error

const val5: any = unknownVar
const val6: unknown = unknownVar
```

`unknown` 和 `any` 的主要差异体现在赋值给别的变量时，any 就像是 **“我身化万千无处不在”** ，所有类型都把它当自己人。而 unknown 就像是 **“我虽然身化万千，但我坚信我在未来的某一刻会得到一个确定的类型”** ，只有 any 和 unknown 自己把它当自己人。简单地说，any 放弃了所有的类型检查，而 unknown 并没有。

```typescript
let unknownVar: unknown

unknownVar.foo() // Property 'foo' does not exist on type 'unknown'.
```

要对 `unknown` 类型进行属性访问，需要进行类型断言



**类型**的上层与底层，其实即意味着包含类型信息的多少

### never

TS 内置的 `never` 类型是一个“什么都没有”的类型，也就是**不携带任何的类型信息** 

由于没有任何类型信息，在联合类型中出现被直接移除

![](https://oss.xiefeng.tech/images/20221229173836.png)

#### 特点

`void` 和 `never` 的类型兼容性

```typescript
declare let v1: never
declare let v2: void
v2 = v1
v1 = v2  // Type 'void' is not assignable to type 'never'.
```

- `void` 类型就像 JS 中的 `null` 一样代表“这里有类型，但是个空类型”
- `never` 还要更加空白， 它才是一个“什么都没有”的类型，甚至不包括空的类型
  - 联合类型中可以保留 `void` 类型，会剔除 `never` 类型
  - `never` 类型可以赋值给 `void` 类型变量

`never` 类型实质上是编程语言的类型系统中的 **Bottom Type**，是**整个类型系统层级中最底层的类型** 

它是所有类型的子类型，只有 `never` 类型的变量能够赋值给另一个 `never` 类型变量

#### 使用

通常我们不会显式地声明一个 `never` 类型，它主要被类型检查所使用。

在某些情况下使用 `never` 确实是符合逻辑的，比如一个只负责抛出错误的函数

```typescript
function justThrow(): never {
  throw new Error()
}
```

在类型流的分析中，一旦一个返回值类型为 `never` 的函数被调用，下方的代码都会被视为无效的代码

对于联合类型的变量，每经过一个 `if` 语句块，变量的类型分支就会减少一个

最后它的类型只剩下了 `never`  类型，即一个无法再细分、本质上并不存在的虚空类型

```typescript
declare const mixed: string | number | boolean

if (typeof mixed === 'string') {
  mixed.charAt(1)
} else if (typeof mixed === 'number') {
  mixed.toFixed()
} else if (typeof mixed === 'boolean') {
  mixed === true
} else {
  const exhaustiveCheck: never = mixed
  throw new Error(`Unknown input type: ${exhaustiveCheck}`)
}
```

借助 TS 强大的类型分析能力，在类型检查时，就可以将这个变量的每一种类型都需要得到妥善处理

如果增了一个类型分支，最后的代码块中就会出现将其他类型赋值给 `never` 类型变量的类型错误，确保我们对每一种类型可能都有对应的处理

```typescript
declare const mixed: string | number | boolean | symbol

// Type 'symbol' is not assignable to type 'never'.
const exhaustiveCheck: never = mixed
```

 当开启 `strictNullChecks` 同时禁用 `noImplicitAny` 时，数组默认会被推导为 `never[]` 类型

```typescript
const arr = []

arr.push('') // Argument of type 'string' is not assignable to parameter of type 'never'.
```

## 类型断言

类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型

也就是将一个变量的已有类型更改为新指定类型的操作

基本语法是 `as NewType`、`<NewType>` ，`<>` 语法虽然书写更简洁，在 TSX 中尖括号断言并不能很好地被分析出来

- 你可以将 `any` / `unknown` 类型断言到一个具体的类型
- 还可以断言为 `any` 来为所欲为，跳过所有的类型检查

```typescript
declare const unknownVar: unknown

(unknownVar as { foo: () => {} }).foo()

declare const str: string

(str as any).func().foo().prop
```

类型断言的正确使用应是在 TypeScript 类型分析不正确或不符合预期时，将其断言为此处的正确类型

### 双重断言

如果在使用类型断言时，原类型与断言类型之间差异过大，TypeScript 会给你一个类型报错

```typescript
declare const str: string

(str as { handler: () => {} }).handler()
// Conversion of type 'string' to type '{ handler: () => {}; }' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first
```

它会提醒你先断言到 `unknown` 类型，再断言到预期类型

```typescript
declare const str: string

(str as unknown as { handler: () => {} }).handler()

(<{ handler: () => {} }>(<unknown>str)).handler()
```

### 非空断言

非空断言使用 `!` 语法标记前面的一个声明一定是非空的，也就是剔除了 `null` 和 `undefined` 类型

```typescript
declare const foo: {
  func?: () => ({
    prop?: number | null
  })
}

foo.func!().prop!.toFixed()
```

非空断言实质上是类型断言的简化，因为上面的非空断言实际上等价于以下的类型断言操作

```typescript
((foo.func as () => ({
  prop?: number
}))().prop as number).toFixed()
```

### 巧妙使用

类型断言的一种用法是作为代码提示的辅助工具

```typescript
interface IStruct {
  foo: string
  bar: {
    barPropA: string
    barPropB: number
    barMethod: () => void
    baz: {
      handler: () => Promise<void>
    }
  }
}
```

假设你想要基于这个结构随便实现一个对象，你可能会使用类型标注

```typescript
const obj: IStruct = {}
```

这个时候等待你的是一堆类型报错，你必须规规矩矩地实现整个接口结构才可以

如果使用类型断言，可以在保留类型提示的前提下，不那么完整地实现这个结构

```typescript
const obj = <IStruct>{
  bar: {
    baz: {},
  },
}
```







## 类型工具

### 类型别名

通过 `type` 关键字声明类型别名

类型别名的作用主要是对一组类型或一个特定类型结构进行封装，以便于在其它地方进行复用

```typescript
type StatusCode = 200 | 301 | 400 | 500 | 502

type Handler = (e: Event) => void
```

在类型别名中可以声明自己能够接受泛型

```typescript
type MaybeNull<T> = T | null

type MaybeArray<T> = T | T[]
```

### 交叉类型

**交叉类型**和联合类型类似，只不过符号是 `&`，即按位与运算符

- 联合类型 `|` 代表了按位或，只需要满足其中一个类型即可
- 按位与 `&` 则不同，需要满足其中所有类型的要求

```typescript
interface ButtonBaseProps {
  disabled: boolean
  loading: boolean
  onClick: React.MouseEventHandler<HTMLElement | HTMLAnchorElement>
}

type HTMLButtonAttributes = React.ButtonHTMLAttributes<HTMLElement>

type AnchorButtonProps = {
  href: string
  target: string
} & ButtonBaseProps & Omit<HTMLButtonAttributes, 'type' | 'onClick'>
```

对于无法同时满足的类型，交叉类型的结果为 `never`，这也是该类型的实际意义之一，描述**根本不存在的类型** 

```typescript
type StrAndNum = string & number // never
```

对于对象类型的交叉类型，其内部的同名属性类型同样会按照交叉类型进行合并

```typescript
type Struct1 = {
  primitiveProp: string
  objectProp: { name: string }
}

type Struct2 = {
  primitiveProp: number
  objectProp: { age: number }
}

type Composed = Struct1 & Struct2

type PrimitiveProp = Composed['primitiveProp'] // never
type ObjectProp = Composed['objectProp'] // { name: string; age: number; }
```

对于多个联合类型组成的交叉类型，取多个联合类型的交集：

```typescript
type Union_1 = (1 | 2 | 3) & (1 | 2)  // 1 | 2
type Union_2 = (string | number | symbol) & string  // string
```

### 索引类型

索引类型包含三个部分：**索引签名类型**、**索引类型查询**与**索引类型访问** 

实际上这三者都是独立的类型工具。唯一共同点是，**它们都通过索引的形式来进行类型操作**

但索引签名类型是**声明**，索引类型查询和索引类型访问则是**读取** 

#### 索引签名类型

索引签名类型指在**接口**或**类型别名**中，通过 `[k: T]: V` 语法**快速声明一个键值类型一致的结构** 

```typescript
interface AllStringTypes {
  [key: string]: string
}

type AllStringTypes = {
  [key: string]: string
}
```

即使还没声明具体的属性，对于这些类型结构的属性访问也将全部被视为 `string` 类型

```typescript
interface AllStringTypes {
  [key: string]: string
}

type PropType = AllStringTypes['ddd'] // string
```

由于在 JavaScript 中对 `obj[prop]` 形式的访问会将**数字索引访问转换为字符串索引访问**

所以在字符串索引签名类型中我们仍然可以声明数字类型的键，同样也可以使用 `symbol` 类型

```typescript
const foo: AllStringTypes = {
  599: '599',
  'demo': 'demo',
  [Symbol("ddd")]: 'symbol',
}
```

索引签名类型可以和具体的键值对类型声明并存，但此时键值类型需要符合索引签名类型的声明

```typescript
interface AllStringTypes {
// Property 'propA' of type 'number' is not assignable to 'string' index type 'boolean'.
  propA: number 
  [key: string]: boolean
}
```

索引签名类型的一个常见场景是在重构 JavaScript 代码时，为内部属性较多的对象声明一个 `any` 的索引签名类型，以此来暂时支持**对类型未明确属性的访问**，并在后续一点点补全类型

```typescript
interface AnyTypeHere {
  [key: string]: any
}

const foo: AnyTypeHere['xxx'] = 'any value'
```

#### 索引类型查询

索引类型查询，也就是 `keyof` 操作符

它可以将对象中的所有**键**转换为对应**字面量**类型，然后再组合成**联合类型** 

**这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然保持为数字类型字面量** 

```typescript
interface Foo {
  bar: 1,
  599: 2
}

type FooKeys = keyof Foo // 'bar' | 599
```

除了应用在已知的对象类型结构上以外，可以直接通过 `keyof any` 产生一个联合类型

- 其结果为所有可用作对象键值的类型组成：`string | number | symbol`
- 也可以说 `any` 由无数字面量类型组成的

可以看出 `keyof` **的产物必定是一个联合类型** 

#### 索引类型访问

在 JavaScript 中我们可以通过 `obj[expression]` 的方式来动态访问一个对象属性

TypeScript 中我们也可以通过类似的方式动态的访问类型

```typescript
interface NumberRecord {
  [key: string]: number
}

type PropType = NumberRecord[string] // number
```

更直观的例子是通过字面量类型来进行索引类型访问

```typescript
interface Foo {
  propA: number
  propB: boolean
}

type PropAType = Foo['propA'] // number
type PropBType = Foo['propB'] // boolean
```

索引类型访问的本质就是，**通过键的字面量类型访问这个键对应的键值类型** 

`keyof` 操作符能一次性获取这个对象所有的键的字面量类型，同样也能用在这里

```typescript
interface Foo {
  propA: number
  propB: boolean
  propC: string
}

type PropTypeUnion = Foo[keyof Foo] // string | number | boolean
```

使用**联合类型**进行索引类型访问就是将联合类型每个分支对应类型访问后的结果组装成新的联合类型

在未声明索引签名类型的情况下，无法使用 `Type[string]` 这种原始类型的访问方式，只能通过键名的字面量类型进行访问

```typescript
interface Foo {
  propA: number
}

// 类型“Foo”没有匹配的类型“string”的索引签名。
type PropAType = Foo[string] 
```

### 映射类型

索引类型的最佳拍档之一就是映射类型，映射类型也是类型编程中常用的一个手段

映射类型的主要作用即是**基于键名映射到键值类型** 

```typescript
type Stringify<T> = {
  [K in keyof T]: string
}
```

映射类型（通过 `in` 关键字）即将联合类型的每一个成员映射出来

- `K in ` 属于映射类型的语法
- `keyof T ` 属于 `keyof` 操作符
- `[K in keyof T]` 的 `[]` 属于索引签名类型
- `T[K]`属于索引类型访问

```typescript
type Clone<T> = {
  [K in keyof T]: T[K]
}
```

### 类型查询

TypeScript 中存在两种功能不同的 `typeof` 操作符

- 用于检查变量类型 ，它会返回 `"string"` / `"number"` / `"object"` / `"undefined"` 等值
- 用于类型查询，即 **Type Query Operator**，其返回值为一个 TS 类型

```typescript
const str = 'str'
const obj = { name: '' }

const nullVar = null
const undefinedVar = undefined

const func = (input: string) => {
  return input.length > 10
}

type Str = typeof str // 'str'
type Obj = typeof obj // { name: string }
type Null = typeof nullVar // null
type Undefined = typeof undefined // undefined
type Func = typeof func // (input: string) => boolean
```

一般 `typeof` 返回的类型就是把鼠标悬浮在变量名上时出现的类型，并且是**最窄的推导程度（即到字面量类型的级别）** 

不必担心混用了这两种 typeof，

- 在逻辑代码中使用的一定是 JavaScript 中的 `typeof`
- 类型代码（如类型标注、类型别名等）中的一定是类型查询的 `typeof`

为了更好地隔离类型层和逻辑层，类型查询操作符后是不允许使用表达式的

```typescript
const isInputValid = (input: string) => {
  return input.length > 10
}

declare const isValid: typeof isInputValid('str') // ',' expected.
```











## 条件类型

条件类型的语法类似于三元表达式，将等号换成 `extends` 

```typescript
type Result = TypeA extends TypeB ? Result1 : Result2
```

条件类型中使用 extends 判断类型的兼容性，而非类型的全等性

在类型层面中，对于能够进行赋值操作的两个变量，**并不需要它们的类型完全相等，只需要具有兼容性**

而两个完全相同的类型，使用 extends 比较自然也是成立的

条件类型绝大部分场景下会和泛型一起使用，基于填充后的泛型参数做进一步的类型操作

同三元表达式可以嵌套一样，条件类型中可以多层嵌套

```typescript
export type LiteralType<T> = T extends string
	? "string"
	: T extends number
		? "number"
		: T extends boolean
			? "boolean"
			: T extends null
				? "null"
				: T extends undefined
					? "undefined"
					: never;

type Res1 = LiteralType<"linbudu">; // "string"
type Res2 = LiteralType<599>; // "number"
type Res3 = LiteralType<true>; // "boolean"
```

存在泛型约束和条件类型两个 extends 可能会让你感到疑惑，但它们产生作用的时机完全不同，泛型约束要求你传入符合结构的类型参数，相当于**参数校验**。而条件类型使用类型参数进行条件判断（就像 if else），相当于**实际内部逻辑**。

## infer

TypeScript 中支持通过 infer 关键字来**在条件类型中提取类型的某一部分信息** 

```typescript
type FunctionReturnType<T extends Func> = T extends (
  ...args: any[]
) => infer R
  ? R
  : never;
```

不用管 `infer R`，当它是 any 就行，返回 `infer R ` 位置的值，即 R

`infer`是 `inference` 的缩写，意为推断，如 `infer R` 中 `R` 就表示 **待推断的类型** 

 `infer` 只能在条件类型中使用，因为我们实际上仍然需要**类型结构是一致的** 

这里的**类型结构**当然并不局限于函数类型结构，还可以是数组：

```typescript
type Swap<T extends any[]> = T extends [infer A, infer B] ? [B, A] : T;

type SwapResult1 = Swap<[1, 2]>; // 符合元组结构，首尾元素替换[2, 1]
type SwapResult2 = Swap<[1, 2, 3]>; // 不符合结构，没有发生替换，仍是 [1, 2, 3]
```

